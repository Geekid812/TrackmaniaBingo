// This file is automatically @generated by the `typegen` tool.
// Do not manually edit it! See `common/types.xml` for details.


/* It's the first type. */
class TypeFirst {
    int value;
    uint other;
    TypeFirst() {}
}

namespace TypeFirst {
    Json::Value@ Serialize(TypeFirst cls) {
        auto value = Json::Object();
        value["value"] = cls.value;
        value["other"] = cls.other;

        return value;
    }

    TypeFirst Deserialize(Json::Value@ value) {
        auto cls = TypeFirst();
        cls.value = value["value"];
        cls.other = value["other"];

        return cls;
    }
}


class TypeSecond {
    string text;
    TypeSecond() {}
}

namespace TypeSecond {
    Json::Value@ Serialize(TypeSecond cls) {
        auto value = Json::Object();
        value["text"] = cls.text;

        return value;
    }

    TypeSecond Deserialize(Json::Value@ value) {
        auto cls = TypeSecond();
        cls.text = value["text"];

        return cls;
    }
}


/* This struct has more complex members. */
class Complex {
    array<int> one;
    string two;
    array<TypeFirst>@ three;
    Complex() {}
}

namespace Complex {
    Json::Value@ Serialize(Complex cls) {
        auto value = Json::Object();
        value["one"] = cls.one;
        value["two"] = cls.two;
        value["three"] = cls.three;

        return value;
    }

    Complex Deserialize(Json::Value@ value) {
        auto cls = Complex();
        for (uint i = 0; i < value["one"].Length; i++) {
            cls.one.InsertLast(value["one"][i]);
        }
        if (value["two"].GetType() != Json::Type::Null) cls.two = value["two"];
        if (value["three"].GetType() != Json::Type::Null) for (uint i = 0; i < value["three"].Length; i++) {
            cls.three.InsertLast(TypeFirst::Deserialize(value["three"][i]));
        }

        return cls;
    }
}
