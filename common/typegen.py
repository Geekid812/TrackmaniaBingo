#!/usr/bin/python3

# -- Imports
import sys
from dataclasses import dataclass

try:
    import xmlschema
except ImportError:
    print("The package `xmlschema` was not found in the environment. Install it using pip to run this script.", file=sys.stderr)
    exit(1)


# -- Definitions
@dataclass
class TypeDef:
    angelscript: str
    rust: str
    serde_as: str = None


types = {
    "int": TypeDef("int", "i32"),
    "uint": TypeDef("uint", "u32"),
    "string": TypeDef("string", "String"),
    "bool": TypeDef("bool", "bool"),
    "rgbColor": TypeDef("vec3", "Color"),
    "datetime": TypeDef("uint64", "DateTime<Utc>", serde_as="TimestampSeconds"),
    "duration": TypeDef("int64", "Duration", serde_as="DurationMilliSeconds<i64>"),
}

rust_header = """\
// This file is automatically @generated by the `typegen` tool.
// Do not manually edit it! See `common/types.xml` for details.
#![allow(unused_imports)]
use chrono::{DateTime, Duration, Utc};
use derivative::Derivative;
use serde::{Deserialize, Serialize};
use serde_repr::{Deserialize_repr, Serialize_repr};
use serde_with::{serde_as, DurationMilliSeconds, TimestampSeconds};

use crate::util::Color;
"""

rust_struct = """\
%s
#[serde_as]
#[derive(Serialize, Deserialize, Debug, Clone, Derivative, PartialEq, Eq)]
#[derivative(Default)]
#[serde(default)]
pub struct %s {
    %s,
}
"""

rust_enum = """\
%s
#[derive(Serialize_repr, Deserialize_repr, Debug, PartialEq, Eq, Copy, Clone, Default)]
#[repr(u8)]
pub enum %s {
    #[default]
    %s,
}
"""

angelscript_header = """\
// This file is automatically @generated by the `typegen` tool.
// Do not manually edit it! See `common/types.xml` for details.
"""

angelscript_class = """\
%s
class %s {
    %s;
    %s() {}
}
"""

angelscript_enum = """\
%s
enum %s {
    %s,
}
"""

angelscript_impl = """\
namespace @name {
    Json::Value@ Serialize(@name cls) {
        auto value = Json::Object();
        %s

        return value;
    }

    @name Deserialize(Json::Value@ value) {
        auto cls = @name();
        %s

        return cls;
    }
}
"""


def parse_member(m: dict) -> (str, bool, bool, str):
    tname = m["@type"]
    optional = "@optional" in m and m["@optional"]
    is_list = tname.startswith("list[") and tname[-1] == "]"
    default = m["@default"] if "@default" in m else None

    if is_list:
        tname = tname[5:-1]

    return tname, optional, is_list, default


def enum_list(e: dict) -> list[str]:
    values = []
    for value in e['v']:
        if type(value) is dict and "@id" in value:
            value = f"{value['$']} = {value['@id']}"
        values.append(value)
    return values


def snake_case_to_camel_case(snake: str) -> str:
    words = snake.split('_')
    return words[0] + ''.join(w.title() for w in words[1:])


# -- Load schema
with open("schema/types.xsd", "r") as f:
    schema = xmlschema.XMLSchema(f)

with open("types.xml", "r") as f:
    try:
        xs = schema.to_dict("types.xml")
    except xmlschema.XMLSchemaDecodeError as e:
        print(e.msg, file=sys.stderr)
        exit(1)

# -- Write Rust bindings
print("Writing Rust bindings...", end=' ')


def rust_typeof(m, datatypes) -> str:
    tname, optional, is_list, _ = parse_member(m)

    if tname in types:
        rust_type = types[tname].rust
    elif tname in datatypes:
        rust_type = tname
    else:
        print("Failed")
        print(f"typegen: unknown type '{tname}'.", file=sys.stderr)
        exit(1)

    if is_list:
        rust_type = f"Vec<{rust_type}>"
    if optional:
        rust_type = f"Option<{rust_type}>"

    return rust_type


def rust_as_member(m: dict) -> str:
    tname, optional, _, default = parse_member(m)
    rtype = rust_typeof(m, datatypes)
    member = f"pub {m['@name']}: {rtype}"
    if rtype == "Duration":
        default = f"Duration::milliseconds({default if default is not None else 0})"

    if tname in types and types[tname].serde_as:
        member = f"#[serde_as(as = \"{types[tname].serde_as}\")]\n\t" + member
    if default:
        if optional:
            default = f"Some({default})"
        member = f"#[derivative(Default(value = \"{default}\"))]\n\t" + member

    return member


with open("../server/src/datatypes.rs", "w") as f:
    f.write(rust_header)

    datatypes = [datatype['@name'] for datatype in xs['struct'] + xs['enum']]
    for struct in xs['struct']:
        members = [
            rust_as_member(m) for m in struct['m']]
        comment = f"\n/* {struct['comment']} */" if "comment" in struct else ""

        f.write(rust_struct %
                (comment, struct["@name"], ",\n    ".join(members)))

    for enum in xs['enum']:
        values = enum_list(enum)
        comment = f"\n/* {enum['comment']} */" if "comment" in enum else ""

        f.write(rust_enum %
                (comment, enum['@name'], ",\n    ".join(values)))

    print("OK!")

# -- Write Angelscript bindings
print("Writing Angelscript bindings...", end=' ')


def angelscript_typeof(m, datatypes) -> str:
    tname, optional, is_list, _ = parse_member(m)
    is_struct_type = False

    if tname in types:
        as_type = types[tname].angelscript
    elif tname in datatypes:
        as_type = tname
        is_struct_type = True
    else:
        print("Failed")
        print(f"typegen: unknown type '{tname}'.", file=sys.stderr)
        exit(1)

    if is_list:
        as_type = f"array<{as_type}>"
    if optional and is_struct_type:
        as_type = f"{as_type}@"

    return as_type


def as_serialize(struct: dict) -> str:
    """
    Generate Angelscript Type::Serialize() implementation
    """
    statements = []
    for m in struct['m']:
        tname, _, is_list, _ = parse_member(m)
        is_enum_type = tname in [e['@name'] for e in xs['enum']]
        is_struct_type = (not (tname in types)
                          and not is_enum_type)
        mname = snake_case_to_camel_case(m['@name'])
        if tname == 'rgbColor':
            tname = 'Color'
            is_struct_type = True

        cls = f"cls.{mname}"
        if is_struct_type:
            cls = f"{tname}::Serialize({cls}{'[i]' if is_list else ''})"
        if is_enum_type:
            cls = f"int({cls})"

        if is_list and (is_struct_type or is_enum_type):
            stmt = "array<Json::Value@> {0} = {{}};\n        for (uint i = 0; i < {1}.Length; i++) {{\n            {0}.InsertLast({2});\n        }}\n        value[\"{3}\"] = {0};".format(
                mname, f"cls.{mname}", cls, m['@name'])
        else:
            stmt = f"value[\"{m['@name']}\"] = {cls};"

        statements.append(stmt)

    return "\n        ".join(statements)


def as_deserialize(struct: dict) -> str:
    """
    Generate Angelscript Type::Deserialize() implementation
    """
    statements = []
    for m in struct['m']:
        tname, optional, is_list, _ = parse_member(m)
        is_enum_type = tname in [e['@name'] for e in xs['enum']]
        is_struct_type = (not (tname in types)
                          and not is_enum_type)
        mname = snake_case_to_camel_case(m["@name"])
        if tname == 'rgbColor':
            tname = 'Color'
            is_struct_type = True

        value = f"value[\"{m['@name']}\"]"
        if is_list:
            value += "[i]"
        if is_struct_type:
            value = f"{tname}::Deserialize({value})"
        if is_enum_type:
            value = f"{tname}(int({value}))"

        stmt = f"cls.{mname} = {value};"
        if is_list:
            stmt = "for (uint i = 0; i < value[\"{2}\"].Length; i++) {{\n            cls.{0}.InsertLast({1});\n        }}".format(
                mname, value, m['@name'])
        if optional:
            stmt = f"if (value[\"{m['@name']}\"].GetType() != Json::Type::Null) " + stmt
        statements.append(stmt)

    return "\n        ".join(statements)


def angelscript_as_member(m: dict) -> str:
    tname, _, _, default = parse_member(m)
    member = f"{angelscript_typeof(m, datatypes)} {snake_case_to_camel_case(m['@name'])}"
    if default:
        if tname == "string":
            default = f"\"{default}\""
        member += f" = {default}"

    return member


with open("../client/src/datatypes.as", "w") as f:
    f.write(angelscript_header)

    datatypes = [struct['@name'] for struct in xs['struct'] + xs['enum']]
    for struct in xs['struct']:
        members = [
            angelscript_as_member(m) for m in struct['m']]
        comment = f"\n/* {struct['comment']} */" if "comment" in struct else ""

        f.write(angelscript_class %
                (comment, struct["@name"], ";\n    ".join(members), struct['@name']))

        serialize_impl = as_serialize(struct)
        deserialize_impl = as_deserialize(struct)
        f.write(angelscript_impl.replace(
            "@name", struct["@name"]) % (serialize_impl, deserialize_impl))

    for enum in xs['enum']:
        values = enum_list(enum)
        comment = f"\n/* {enum['comment']} */" if "comment" in enum else ""

        f.write(angelscript_enum %
                (comment, enum['@name'], ",\n    ".join(values)))
    print("OK!")

print(f"Generated bindings for {len(xs['struct'])} types.")
