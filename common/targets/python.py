from . import common

python_header = """\
# This file is automatically @generated by the `typegen` tool.
# Do not manually edit it! See `common/types.xml` for details.

from datetime import datetime, timedelta
from enum import Enum

from pydantic import BaseModel

color = list[int]
"""

python_class = """\
%s
class %s(BaseModel):
    %s
"""

python_enum = """\
%s
class %s(Enum):
    %s
"""



def python_typeof(m, datatypes) -> str:
    tname, optional, is_list, _ = common.parse_member(m)

    if tname in common.types:
        python_type = common.types[tname].python
    elif tname in datatypes:
        python_type = tname
    else:
        print("Failed")
        print(f"typegen: unknown type '{tname}'.", file=sys.stderr)
        exit(1)

    if is_list:
        python_type = f"list[{python_type}]"
    if optional:
        python_type = f"{python_type} | None"

    return python_type


def python_as_member(m: dict, datatypes: list, schema: dict) -> str:
    tname, optional, _, default = common.parse_member(m)
    pytype = python_typeof(m, datatypes)

    member = f"{m['@name']}: {pytype}"

    if default:
        if pytype == "timedelta":
            default = f"timedelta(seconds={default if default is not None else 0})"
        
        is_enum_type = tname in [e['@name'] for e in schema['enum']]
        if is_enum_type:
            base, value = default.split('::', maxsplit=1)
            default = f"{base}.{value.upper()}"

        if pytype == 'bool':
            default = default.capitalize()

        member += f" = {default}"

    return member

def write_python_bindings(schema: dict, path: str):
    print("Writing Python bindings...", end=' ')

    with open(path, "w") as f:
        f.write(python_header)

        datatypes = [datatype['@name'] for datatype in schema['struct'] + schema['enum']]
        for enum in schema['enum']:
            values = [f"{e.upper()} = {i}" for i, e in enumerate(common.enum_list(enum))]
            comment = f"\n# {enum['comment']}" if "comment" in enum else ""

            f.write(python_enum %
                    (comment, enum['@name'], "\n    ".join(values)))

        for struct in schema['struct']:
            members = [
                python_as_member(m, datatypes, schema) for m in struct['m']]
            comment = f"\n# {struct['comment']}" if "comment" in struct else ""

            f.write(python_class %
                    (comment, struct["@name"], "\n    ".join(members)))

        print("OK!")
